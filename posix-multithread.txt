------------
第5章

5.1 一次性初始化

	一些事情仅仅需要做一次，不管是什么。在主函数中并且在调用任何其他依赖于初始化的事物之前初始化应用最容易，特别是在创造任何线程之前初始化它需要的数据，如互斥量、线程特定数据键等。
	
	如果你正在编写一个函数库，通常没有必要做这些，但是必须确保你能使用需要被初始化的任何东西以前已完成必要的初始化。静态初始化的互斥量能给我们很多帮助，但是有时你会发现“一次性初始化”特性方便很多。
	
	在传统的顺序编程中，一次性初始化经常通过使用布尔变量来管理。控制变量被静态地初始化为0，而任何依赖于初始化的代码都能测试该变量。如果变量值仍然为0，则它能实行初始化，然后将变量置为1。以后检查的代码将跳过初始化。

	正在使用多线程时，上述工作就不是那么容易了。如果多个线程并发地执行初始化序列代码，2个线程可能都发现initializer为0，并且都实行初始化，而该过程本该仅仅执行一次。初始化的状态是必须由互斥量保护的共享不变量。

	可以使用一个布尔变量和一个静态初始化的互斥量来编写一次性初始化代码。在许多情况中，这比pthread_once更有效、更方便。使用pthread_once的主要原因是原来不能静态地初始化一个互斥量。这样，为使用一个互斥量，不得不首先调用pthread_mutex_init初始化互斥量。必须仅仅初始化互斥量一次，因此初始化调用应在一次性初始化代码中进行。pthread_once解决了这个递归问题。当互斥量的静态初始化被加到标准中时，pthread_once作为便利功能被保留下来。如果它是方便的，就使用它，但是不必一定使用它。

	首先，需要声明类型为pthread_once_t的一个控制变量。控制变量必须使用PTHREAD_ONCE_INIT宏静态地初始化，如以下实例once.c中显示的那样。还必须创建一个包含与控制变量相关联的所有初始化代码的函数。现在，线程可以在任何时间调用pthread_once，指定一个指向控制变量的指针和指向相关初始化函数的指针。
	
	pthread_once函数首先检查控制变量，以判断是否已经完成初始化。如果完成，pthread_once简单地返回；否则，pthread_once调用初始化函数（没有参数），并且记录下初始化被完成。如果在一个线程初始化时，另外的线程调用pthread_once，则调用线程将等待，直到那个线程完成初始化后返回。换句话说，当调用pthread_once成功返回时，调用者能够肯定所有的状态已经初始化完毕。
	
	函数once_init_routine用来初始化互斥量。pthread_once的使用保证它只被调用一次。
	
	线程函数thread_routine在使用互斥量前调用pthread_once，保证就算它没有被主函数创建，它也好存在。
	
	主程序也在使用互斥量前调用pthread_once，以便程序无论何时都正确执行。注意，虽然我通常强调所有共享数据必须在创造使用它的任何线程前被初始化，而在这种情况中，唯一的临界共享数据实际是once_block，它是不关心互斥量是否被初始化，因为pthread_once的使用保证了合适的同步。

5.2 属性
	
	到目前为止，当我们创建线程或动态初始化互斥量和条件变量时，通常使用空指针作为第二个参数，这个参数实际上是指向一个属性对象的指针。空指针表明，Pthread应该为所有属性假定默认值，就像静态初始化互斥量或条件变量时一样。
	
	一个属性对象是当初始化一个对象时提供的一个拓展参数表，它允许主要的接口（例如，pthread_create）比较简单，同时当你需要时又提供“高级”的功能。以后的POSIX标准将增加选择功能而不必要求改变现有的代码。除了由Pthreads提供的标准属性外，具体实现可以提供专业化的选择（不用创建非标准的参数）。
	
	可以将属性对象视为一个私有结构。通过特殊的函数读或写结构的“成员”，而非通过存取公共的成员命名。例如，通过pthread_attr_getstacksize调用从线程属性对象中读stacksize属性，或调用pthread_attr_setstacksize写该属性。
	
	在Pthreads的简单实现中，类型pthread_attr_t可能是一typedef结构，并且get和set函数可能是读或写变量成员的宏。另外的实现可能在初始化属性对象时分配内存，并且它可以将get和set函数实现为执行有效性检查的真正的函数。
	
	线程、互斥量和条件变量都要自己特殊的属性对象类型，分别是pthread_attr_t、pthread_mutexattr_t和pthread_condattr_t。
	
5.2.1 互斥量属性
	
	Pthreads为互斥量创建定义下列属性：pshared、protocol和prioceiling，然而并没有要求系统一定实现这些属性，所以在使用它们前要检查系统文档。
	
	通过调用pthread_mutexattr_init初始化互斥量属性，指定一个指向类型pthread_mutexattr_t变量的指针，如以下实例mutex_attr.c所示。通过把它的地址（而不是我们到目前为止一直在使用的空值）传递给pthread_mutex_init来使用那个属性对象。
	
	如果系统提供_POSIX_THREAD_PROCESS_SHARED选项，则它支持pshared属性，可以调用pthread_mutexattr_setpshared来设置它。如果将pshared属性置为PTHREAD_PROCESS_SHARED，就能使用互斥量在多个进程间同步线程，这些线程能访问用来初始化互斥量（pthread_mutex_t）的存储器。该属性的默认值是PTHREAD_PROCESS_PTIVATE。

	mutex_attr.c程序显示了如何设置属性对象来创建使用pshared属性的互斥量。这个例子使用默认值PTHREAD_PROCESS_PRIVATE，避免创建共享存储器和派生进程所带来的附加复杂性。另外的互斥量属性、协议和prioceiling将以后的5.5.5节中讨论。

5.2.2 条件变量

	Pthreads为条件变量的创建仅定义了一个属性pshared。没有系统被要求实现该属性，这样在使用它之前应检查系统文档。使用pthread_condattr_init初始化条件变量属性对象，设置一个指向类型pthread_condattr_t变量的指针，如下例cond_attr.c所示。通过将其他地址传递给pthread_cond_init(而不是我们到目前为止一直在使用的空值)使用该属性对象。
	
	如果系统定义了——POSIX_THREAD_PROCESS_SHARED，则它支持pshared属性。通过调用pthread_condattr_setpshared设置pshared。如果将pshared属性置为PTHREAD_PROCESS_SHARED，条件变量能被多个进程中的线程使用，这些进程能访问初始化条件变量（pthread_cond_t）的存储器。该属性的默认值是PTHREAD_PROCESS_PRIVATE。
	
	cond_arrt.c程序显示了如何设置一个条件变量属性来创建使用pshared属性的条件变量。这个例子使用默认值PTHREAD_PROCESS_PRIVATE，避免创建共享存储器和派生进程带来的附加复杂性。
	
	为使用一个PTHREAD_PROCESS_SHARED条件变量，必须使用一个PTHREAD_PROCESS_SHARED互斥量，因为同步使用一个条件变量的两个线程必须使用一样的互斥量。等待一个条件变量会自动地解锁、然后加锁相关的互斥量，因此如果互斥量没与PTHREAD_PROCESS_SHARED一起被创建，同步不会工作。
	
5.2.3 线程属性

	POSIX为线程创建定义下列属性：detachstate、stacksize、stackaddr、scope、inheritsched、schedpolicy和schedparam。一些系统不会支持所有这些属性，因此需要在使用它们前检查系统文档。使用pthread_attr_init初始化属性对象，指定一个指向pthread_attr_t类型变量的指针，如程序thread_attr.c所示。将属性对象地址作为第二个参数传递，来使用创建的属性对象。
	
	所有的Pthreads系统都支持detachstate属性，该属性的值可以是PTHREAD_CREATE_JOINABLE或PTHREAD_CREATE_DETACHED。默认的，线程被创建为可连接的（joinable），即意味着由pthread_create创建的该线程ID能被用来与线程连接并获得它的返回值，或取消它。如果将detachstate属性设为PTHREAD_CREATE_DETACHED，使用该属性对象创建的线程ID不能被使用，也就意味着，当线程终止时，它使用的任何资源将立刻被系统回收。
	
	当创建已经知道不需要取消或连接的线程时，应该以可分离的方式创建它们。记住，在许多情况中，就算你想要知道一个线程什么时候终止，或获得它的返回值，也不必需要使用pthread_join。如果你提供自己的通知机制，如使用一个条件变量，仍然能创建可分离的线程。
	
	设置堆栈大小不是可移植的。
	
	如果你的系统定义了标志_POSIX_THREAD_ATTR_STACKSZE，就可以设置stacksize属性，指定使用属性对象创建的线程栈的最小值。大多数系统将支持该选项，但是因为栈大小不是可移植的，你应该小心使用它。所需的栈空间数量取决于每个系统使用的调用标准和数据格式。
	
	Pthreads定义PTHREAD_STACK_MIN标志，指定每个线程要求的最小栈大小：如果确实需要指定栈大小，能最好以实现要求的最小值计算你的要求。或者，能在实现选择的默认stacksize属性基础上计算你的要求，如默认值的两倍或缺省值的一半。程序thread_attr.c显示了如何调用pthread_attr_getstacksize读取一个初始化的属性的默认stacksize值。
	
	设置堆栈地址将降低可移植性！
	
	如果系统定义了标志_POSIX_THREAD_ATTR_STACKADDR，就可以设置stackaddr属性，为任何使用该属性对象的线程指定一个存储器区域作为堆栈使用。栈至少一定要和PTHREAD_STACK_MIN那样大。你可能需要使用符合某个对齐granularity的地址来指定内存区域。在从上向下的占空间的机器上，指定的地址应该是栈的最高地址，而不是最低地址。如果栈增大，需要指定最低的地址。
	
	你也需要知道在写数据之前或之后，机器是否增加（或减少）栈——这决定了你指定的地址是否应该在分配的堆栈“里面”或“外面”。系统不能告诉你是否分配了足够的空间，或是否指定了正确的地址，因此它不得不信任你。如果你错了，将发生不希望发生的事情。

	要特别小心地使用stackaddr属性，并且注意它可能是Pthreads中最不可移植的。尽管合理的stacksize属性值将可能在大量机器上正常工作，但是很难让任何特别的stackaddr属性值能在任何两台机器上工作。另外，必须记住你能使用statckaddr属性的任何值创建一个线程。如果相同的stackaddr属性值创建两个并发线程，线程将在相同的栈上运行（那可不太好）。

	以下thread_attr.c程序演示实际中的某些属性对象，程序中使用判断条件语句以避免在系统不支持stacksize属性时使用它。如果stacksize被支持（并且它将在大多数UNIX系统上被支持），程序将打印缺省的和最小的栈大小，并且将stacksize设为最小值的两倍。代码还创建可分离的线程，即没有线程能连接它们以判断它们何时结束。相反，主函数调用pthread_exit退出，意味着当最后的线程退出时，进程将终止。
	
	这个例子不包括优先级调度属性，它将在5.5.2节中讨论。它也没有演示stackaddr属性的应用——正如我曾说过的，没有方法以可移植性的方式使用stackaddr，尽管我为完整性考虑提及它，但强烈建议不要在任何程序中使用stackaddr。

5.3 取消

	大部分时间




















